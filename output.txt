.gitignore:
/target
/test/work/
GEMINI.md
---
Cargo.lock:
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "anstream"
version = "0.6.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "301af1932e46185686725e0fad2f8f2aa7da69dd70bf6ecc44d6b703844a3933"
dependencies = [
 "anstyle",
 "anstyle-parse",
 "anstyle-query",
 "anstyle-wincon",
 "colorchoice",
 "is_terminal_polyfill",
 "utf8parse",
]

[[package]]
name = "anstyle"
version = "1.0.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "862ed96ca487e809f1c8e5a8447f6ee2cf102f846893800b20cebdf541fc6bbd"

[[package]]
name = "anstyle-parse"
version = "0.2.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4e7644824f0aa2c7b9384579234ef10eb7efb6a0deb83f9630a49594dd9c15c2"
dependencies = [
 "utf8parse",
]

[[package]]
name = "anstyle-query"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c8bdeb6047d8983be085bab0ba1472e6dc604e7041dbf6fcd5e71523014fae9"
dependencies = [
 "windows-sys",
]

[[package]]
name = "anstyle-wincon"
version = "3.0.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "403f75924867bb1033c59fbf0797484329750cfbe3c4325cd33127941fabc882"
dependencies = [
 "anstyle",
 "once_cell_polyfill",
 "windows-sys",
]

[[package]]
name = "clap"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "be92d32e80243a54711e5d7ce823c35c41c9d929dc4ab58e1276f625841aadf9"
dependencies = [
 "clap_builder",
 "clap_derive",
]

[[package]]
name = "clap_builder"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "707eab41e9622f9139419d573eca0900137718000c517d47da73045f54331c3d"
dependencies = [
 "anstream",
 "anstyle",
 "clap_lex",
 "strsim",
]

[[package]]
name = "clap_derive"
version = "4.5.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ef4f52386a59ca4c860f7393bcf8abd8dfd91ecccc0f774635ff68e92eeef491"
dependencies = [
 "heck",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "clap_lex"
version = "0.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b94f61472cee1439c0b966b47e3aca9ae07e45d070759512cd390ea2bebc6675"

[[package]]
name = "colorchoice"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b05b61dc5112cbb17e4b6cd61790d9845d13888356391624cbe7e41efeac1e75"

[[package]]
name = "heck"
version = "0.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2304e00983f87ffb38b55b444b5e3b60a884b5d30c0fca7d82fe33449bbe55ea"

[[package]]
name = "hermit-abi"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc0fef456e4baa96da950455cd02c081ca953b141298e41db3fc7e36b1da849c"

[[package]]
name = "is-terminal"
version = "0.4.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e04d7f318608d35d4b61ddd75cbdaee86b023ebe2bd5a66ee0915f0bf93095a9"
dependencies = [
 "hermit-abi",
 "libc",
 "windows-sys",
]

[[package]]
name = "is_terminal_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7943c866cc5cd64cbc25b2e01621d07fa8eb2a1a23160ee81ce38704e97b8ecf"

[[package]]
name = "libc"
version = "0.2.174"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1171693293099992e19cddea4e8b849964e9846f4acee11b3948bcc337be8776"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mend"
version = "0.1.0"
dependencies = [
 "clap",
 "is-terminal",
 "once_cell",
 "regex",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "once_cell_polyfill"
version = "1.70.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4895175b425cb1f87721b59f0f286c2092bd4af812243672510e1ac53e2e0ad"

[[package]]
name = "proc-macro2"
version = "1.0.95"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "02b3e5e68a3a1a02aad3ec490a98007cbc13c37cbe84a3cd7b8e406d76e7f778"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "regex"
version = "1.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b544ef1b4eac5dc2db33ea63606ae9ffcfac26c1416a2806ae0bf5f56b201191"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-automata",
 "regex-syntax",
]

[[package]]
name = "regex-automata"
version = "0.4.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "809e8dc61f6de73b46c85f4c96486310fe304c434cfa43669d7b40f711150908"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2b15c43186be67a4fd63bee50d0303afffcef381492ebe2c5d87f324e1b8815c"

[[package]]
name = "strsim"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7da8b5736845d9f2fcb837ea5d9e2628564b3b043a70948a3f0b778838c5fb4f"

[[package]]
name = "syn"
version = "2.0.104"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "17b6f705963418cdb9927482fa304bc562ece2fdd4f616084c50b7023b435a40"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "utf8parse"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "06abde3611657adf66d383f00b093d7faecc7fa57071cce2578660c9f1010821"

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"
---
Cargo.toml:
[package]
name = "mend"
version = "0.1.0"
edition = "2024"

[dependencies]
clap = { version = "4.5.41", features = ["derive"] }
is-terminal = "0.4.16"
once_cell = "1.21.3"
regex = "1.11.1"

[[test]]
name = "auto_detect_test"
path = "test/auto_detect_test.rs"

[[test]]
name = "patching_test"
path = "test/patching_test.rs"
---
LICENSE:
MIT License

Copyright (c) 2025 Tytoo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
---
README.md:
# Mend

Mend is a robust command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Standard `patch` tools often fail when applying AI-generated diffs because the line numbers in the `@@ ... @@` headers are incorrect. `mend` solves this by ignoring line numbers and using a powerful, multi-stage fuzzy matching algorithm to find where the patch should be applied.

## Features

-   **Robust Parsing:** Ignores malformed diff headers, comments, and other conversational artifacts from LLMs.
-   **Fuzzy Matching Engine:** If a strict patch fails, `mend` automatically uses progressively "fuzzier" strategies to find the correct location.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines, gracefully handling most formatting inconsistencies.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if context lines in between have been slightly modified.
-   **Safe by Default:** Applies patches in-place by default, but only overwrites the original file if the entire patch can be applied successfully. If any part fails, the original file is left untouched.

## Installation

Ensure you have the Rust toolchain installed. You can then install `mend` directly from the source code:

```bash
git clone https://your-git-repo-url/mend.git
cd mend
cargo install --path .
```
This will compile `mend` and make it available in your shell.

## Usage

### Basic Usage: Applying a Patch

By default, `mend` applies the patch directly to the file detected in the diff.

```bash
# Auto-detects the original file from the diff and modifies it in-place
mend my_changes.diff
```
*If patching fails, your original file will not be modified.*

You can also specify the original file explicitly:
```bash
mend path/to/original_file path/to/diff_file
```

### Dry Run / Debugging

To see the result without modifying any files, use the `--debug` flag. This will print verbose logs and the final patched output to the console.

```bash
mend --debug my_changes.diff
```

### Piping from Stdin

`mend` can also read the diff from standard input. This is useful for piping directly from another command (like an LLM client).

```bash
# Auto-detects the original file and applies the patch in-place
cat my_changes.diff | mend

# Use --debug for a dry run from stdin
cat my_changes.diff | mend --debug
```

### Controlling Fuzziness and Verbosity

You can manually control the matching strategy with the `--fuzziness` or `-f` flag. The default is `2`.

-   `--fuzziness 0`: Strict mode only. Fails if there isn't an exact match.
-   `--fuzziness 1`: Allows whitespace and empty line differences.
-   `--fuzziness 2` (Default): Enables all strategies, including the powerful anchor-point heuristic.

```bash
# Run in the strictest possible mode
mend --fuzziness 0 my_changes.diff
```

For more detailed logs about what `mend` is doing (without a full debug dry-run), use the `--verbose` or `-v` flag.

```bash
mend --verbose my_changes.diff
```

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file, making it resilient to the incorrect line numbers that LLMs often produce.
---
install.sh:
#!/bin/bash

echo "Building project..."
cargo build --release

if [ $? -eq 0 ]; then
  echo "Build successful."
  echo "Installing mend to /usr/local/bin. Sudo privileges are required."
  sudo mv target/release/mend /usr/local/bin/
  if [ $? -eq 0 ]; then
    echo "Installation successful."
  else
    echo "Installation failed. Could not move the binary."
    exit 1
  fi
else
  echo "Build failed, not installing."
  exit 1
fi
---
src/diff.rs:
#[derive(Debug, Clone)]
pub enum Line {
    Context(String),
    Addition(String),
    Removal(String),
}

#[derive(Debug, Default)]
pub struct Hunk {
    pub lines: Vec<Line>,
}

#[derive(Debug, Default)]
pub struct FileDiff {
    pub old_file: String,
    pub new_file: String,
    pub hunks: Vec<Hunk>,
}

#[derive(Debug, Default)]
pub struct Patch {
    pub diffs: Vec<FileDiff>,
}
---
src/main.rs:
use clap::Parser;
use is_terminal::IsTerminal;
use std::fs;
use std::io::{self, Read};

mod diff;
mod parser;
mod patcher;

#[derive(Parser, Debug)]
#[command(author = "Tytoo", version, about, long_about = None)]
struct Args {
    #[arg(index = 1)]
    diff_file: Option<String>,

    #[arg(long)]
    debug: bool,

    #[arg(short, long, default_value_t = 2)]
    fuzziness: u8,

    #[arg(short, long)]
    verbose: bool,
}

fn main() -> io::Result<()> {
    let args = Args::parse();
    let is_verbose = args.verbose || args.debug;

    if is_verbose {
        println!("mend: A fuzzy diff applicator");
        println!("----------------------------");
    }

    let diff_content = match args.diff_file {
        Some(path) => {
            if is_verbose {
                println!("[INFO] Reading diff from file: {}", path);
            }
            fs::read_to_string(path)?
        }
        None => {
            if io::stdin().is_terminal() {
                eprintln!("[ERROR] No diff file specified and stdin is a terminal.");
                eprintln!("Usage: mend <DIFF_FILE>");
                eprintln!("Or pipe from stdin: git diff | mend");
                std::process::exit(1);
            }
            if is_verbose {
                println!("[INFO] Reading diff from stdin...");
            }
            let mut buffer = String::new();
            io::stdin().read_to_string(&mut buffer)?;
            if buffer.is_empty() {
                eprintln!("[ERROR] Diff content from stdin was empty.");
                std::process::exit(1);
            }
            buffer
        }
    };

    let patch = match parser::parse_patch(&diff_content) {
        Ok(patch) => patch,
        Err(e) => {
            eprintln!("[ERROR] Failed to parse patch: {}", e);
            std::process::exit(1);
        }
    };

    if is_verbose {
        println!("[INFO] Parsed patch with {} file diff(s).", patch.diffs.len());
        println!("[INFO] Applying patches with fuzziness level {}.", args.fuzziness);
    }

    match patcher::apply_patch(&patch, args.fuzziness, args.debug) {
        Ok(_) => {
            if is_verbose {
                println!("[SUCCESS] Patch applied successfully.");
            }
            println!("Successfully applied patch.");
        }
        Err(e) => {
            eprintln!("[ERROR] Could not apply patch: {}", e);
            std::process::exit(1);
        }
    }

    if is_verbose {
        println!("----------------------------");
        println!("Execution finished.");
    }

    Ok(())
}
---
src/parser.rs:
use crate::diff::{FileDiff, Hunk, Line, Patch};

const DIFF_HEADER: &str = "diff --git ";

pub fn parse_patch(patch_content: &str) -> Result<Patch, String> {
    let mut patch = Patch::default();
    let mut current_file_diff: Option<FileDiff> = None;

    for line in patch_content.lines() {
        if line.starts_with(DIFF_HEADER) {
            if let Some(file_diff) = current_file_diff.take() {
                patch.diffs.push(file_diff);
            }
            current_file_diff = Some(FileDiff::default());
        } else if let Some(file_diff) = &mut current_file_diff {
            if line.starts_with("--- a/") {
                file_diff.old_file = line[6..].to_string();
            } else if line.starts_with("+++ b/") {
                file_diff.new_file = line[6..].to_string();
            } else if line.starts_with("@@") {
                file_diff.hunks.push(Hunk::default());
            } else if let Some(current_hunk) = file_diff.hunks.last_mut() {
                if let Some(text) = line.strip_prefix('+') {
                    current_hunk.lines.push(Line::Addition(text.to_string()));
                } else if let Some(text) = line.strip_prefix('-') {
                    current_hunk.lines.push(Line::Removal(text.to_string()));
                } else if let Some(text) = line.strip_prefix(' ') {
                    current_hunk.lines.push(Line::Context(text.to_string()));
                }
            }
        }
    }

    if let Some(file_diff) = current_file_diff.take() {
        patch.diffs.push(file_diff);
    }

    Ok(patch)
}
---
src/patcher.rs:
use crate::diff::{FileDiff, Hunk, Line, Patch};
use std::collections::HashSet;
use std::fs;

const MATCH_SCORE_THRESHOLD: f32 = 0.7;

pub fn apply_patch(
    patch: &Patch,
    fuzziness: u8,
    debug_mode: bool,
) -> Result<(), String> {
    for (i, file_diff) in patch.diffs.iter().enumerate() {
        if debug_mode {
            println!(
                "[DEBUG] Applying diff {}/{} to file {}",
                i + 1,
                patch.diffs.len(),
                file_diff.new_file
            );
        }
        apply_file_diff(file_diff, fuzziness, debug_mode)?;
    }
    Ok(())
}

fn apply_file_diff(
    file_diff: &FileDiff,
    fuzziness: u8,
    debug_mode: bool,
) -> Result<(), String> {
    let original_content = match fs::read_to_string(&file_diff.old_file) {
        Ok(content) => content,
        Err(e) => return Err(format!("Failed to read file {}: {}", file_diff.old_file, e)),
    };

    let mut source_lines: Vec<String> = original_content.lines().map(String::from).collect();

    for (i, hunk) in file_diff.hunks.iter().enumerate() {
        match find_hunk_location(&source_lines, hunk, fuzziness, debug_mode) {
            Some((start_index, matched_length)) => {
                if debug_mode {
                    println!(
                        "[DEBUG] Hunk {}/{} matched at line {} (length {} lines)",
                        i + 1,
                        file_diff.hunks.len(),
                        start_index + 1,
                        matched_length
                    );
                }
                source_lines = apply_hunk(&source_lines, hunk, start_index, matched_length);
            }
            None => {
                return Err(format!(
                    "Failed to apply hunk {}/{}. Could not find matching context.",
                    i + 1,
                    file_diff.hunks.len()
                ));
            }
        }
    }

    let new_content = source_lines.join("\n");
    match fs::write(&file_diff.new_file, new_content) {
        Ok(_) => Ok(()),
        Err(e) => Err(format!("Failed to write file {}: {}", file_diff.new_file, e)),
    }
}

fn find_hunk_location(
    source_lines: &[String],
    hunk: &Hunk,
    fuzziness: u8,
    debug_mode: bool,
) -> Option<(usize, usize)> {
    let anchor_lines: Vec<&String> = hunk
        .lines
        .iter()
        .filter_map(|line| match line {
            Line::Context(text) | Line::Removal(text) => Some(text),
            Line::Addition(_) => None,
        })
        .collect();

    if anchor_lines.is_empty() { return None; }

    if debug_mode {
        println!("[DEBUG]   -> Trying strict match...");
    }
    if let Some(start_index) = source_lines.windows(anchor_lines.len()).position(|window| {
        window.iter().zip(anchor_lines.iter()).all(|(s, a)| s == *a)
    }) {
        return Some((start_index, anchor_lines.len()));
    }

    if fuzziness == 0 { return None; }

    let clean_anchor: Vec<String> = anchor_lines
        .iter()
        .map(|s| normalize_line(s))
        .filter(|s| !s.is_empty())
        .collect();

    if clean_anchor.is_empty() { return None; }

    if fuzziness >= 1 {
        if debug_mode {
            println!("[DEBUG]   -> Trying whitespace-insensitive match...");
        }
        for i in 0..source_lines.len() {
            let mut consumed_lines = 0;
            let mut clean_source_window = Vec::new();
            for (line_offset, line) in source_lines.iter().skip(i).enumerate() {
                consumed_lines = line_offset + 1;
                let normalized = normalize_line(line);
                if !normalized.is_empty() {
                    clean_source_window.push(normalized);
                }
                if clean_source_window.len() == clean_anchor.len() {
                    break;
                }
            }
            if clean_source_window == clean_anchor {
                return Some((i, consumed_lines));
            }
        }
    }

    if fuzziness >= 2 {
        if debug_mode {
            println!("[DEBUG]   -> Trying anchor-point heuristic match...");
        }

        let top_anchor = clean_anchor.first()?;
        let bottom_anchor = clean_anchor.last()?;

        let mut best_match: Option<(usize, usize, f32)> = None;

        for (i, source_line) in source_lines.iter().enumerate() {
            if normalize_line(source_line) == *top_anchor {
                let search_window_end = (i + anchor_lines.len() + 20).min(source_lines.len());

                for (j, inner_source_line) in source_lines.iter().enumerate().skip(i) {
                    if j >= search_window_end { break; }

                    if normalize_line(inner_source_line) == *bottom_anchor {
                        let start_index = i;
                        let length = j - i + 1;
                        let candidate_block = &source_lines[start_index..=j];

                        let score = calculate_match_score(&clean_anchor, candidate_block);
                        if debug_mode {
                            println!("[DEBUG]     - Candidate at lines {}-{} scored {:.2}", i + 1, j + 1, score);
                        }

                        if best_match.is_none() || score > best_match.as_ref().unwrap().2 {
                            best_match = Some((start_index, length, score));
                        }
                    }
                }
            }
        }

        if let Some((start, len, score)) = best_match {
            if score >= MATCH_SCORE_THRESHOLD {
                if debug_mode {
                    println!("[DEBUG]   -> Best anchor-point match found with score {:.2}. Accepting.", score);
                }
                return Some((start, len));
            }
        }
    }

    None
}

fn calculate_match_score(clean_anchor: &[String], candidate_block: &[String]) -> f32 {
    let normalized_candidate_set: HashSet<String> = candidate_block
        .iter()
        .map(|s| normalize_line(s))
        .filter(|s| !s.is_empty())
        .collect();

    if normalized_candidate_set.is_empty() { return 0.0; }

    let mut matches = 0;
    for anchor_line in clean_anchor {
        if normalized_candidate_set.contains(anchor_line) {
            matches += 1;
        }
    }

    matches as f32 / clean_anchor.len() as f32
}

fn apply_hunk(
    source_lines: &[String],
    hunk: &Hunk,
    start_index: usize,
    matched_length: usize,
) -> Vec<String> {
    let mut result = Vec::new();
    result.extend_from_slice(&source_lines[0..start_index]);
    for line in &hunk.lines {
        if let Line::Context(text) | Line::Addition(text) = line {
            result.push(text.clone());
        }
    }
    let end_of_patch_index = start_index + matched_length;
    if end_of_patch_index < source_lines.len() {
        result.extend_from_slice(&source_lines[end_of_patch_index..]);
    }
    result
}

fn normalize_line(line: &str) -> String {
    line.trim().to_string()
}
---
test/auto_detect_test.rs:
use mend::{parser, patcher};
use std::fs;
use std::path::Path;

fn run_autodetect_test(diff_file_name: &str, expected_target_filename: &str, expected_output_name: &str) {
    // SETUP: Ensure the test environment is ready.
    let work_dir = Path::new("test/work");
    if !work_dir.exists() {
        panic!("Test work directory 'test/work' does not exist. Please run test/setup_test_env.sh first.");
    }
    
    // 1. ARRANGE
    let diff_content = fs::read_to_string(Path::new("test/fixtures/diffs").join(diff_file_name))
        .expect("Failed to read diff file");
    
    let original_file_in_work_dir = work_dir.join(expected_target_filename);
    assert!(original_file_in_work_dir.exists(), "Original file {:?} not found in work directory. Did you run setup_test_env.sh?", original_file_in_work_dir);

    // 2. ACT (Phase 1: Auto-detection)
    let detected_file = parser::find_target_file(&diff_content);

    // 3. ASSERT (Phase 1)
    assert!(detected_file.is_some(), "Should have detected a file path");
    let detected_filename = detected_file.unwrap();
    assert_eq!(detected_filename, expected_target_filename, "Auto-detection failed to find the correct filename.");

    let original_content = fs::read_to_string(&original_file_in_work_dir)
        .expect("Failed to read original file from work directory");
    let expected_content = fs::read_to_string(Path::new("test/fixtures/original").join(expected_output_name))
        .expect("Failed to read expected output file");

    // 2. ACT (Phase 2: Patching)
    let parsed_diff = parser::parse_diff(&diff_content);
    let result = patcher::apply_diff(&original_content, &parsed_diff, 2, false); // Use max fuzziness

    // 3. ASSERT (Phase 2)
    assert!(result.is_ok(), "Patching failed: {:?}", result.err());
    assert_eq!(result.unwrap().replace("\r\n", "\n"), expected_content.replace("\r\n", "\n"));
}

#[test]
fn test_autodetect_and_patch_greet() {
    let expected_output = r#"// A simple utility module.

pub fn greet(name: &str) -> String {
    // A more enthusiastic greeting.
    format!("Hello, {}! It is great to see you!", name)
}

pub fn farewell(name: &str) -> String {
    format!("Goodbye, {}.", name)
}
"#;
    fs::write("test/fixtures/original/expected_greet.rs", expected_output).unwrap();

    run_autodetect_test(
        "utils_greet.diff",
        "utils.rs",
        "expected_greet.rs",
    );

    fs::remove_file("test/fixtures/original/expected_greet.rs").unwrap();
}

#[test]
fn test_autodetect_and_patch_farewell() {
    let expected_output = r#"// A simple utility module.

pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

pub fn farewell(name: &str) -> String {
    // A more formal farewell.
    format!("Goodbye and take care, {}.", name)
}
"#;
    fs::write("test/fixtures/original/expected_farewell.rs", expected_output).unwrap();

    run_autodetect_test(
        "utils_farewell.diff",
        "utils.rs",
        "expected_farewell.rs",
    );

    fs::remove_file("test/fixtures/original/expected_farewell.rs").unwrap();
}
---
test/fixtures/diffs/chatgpt.diff:
diff --git a/Personne.java b/Personne.java
index 1234567..89abcde 100644
--- a/Personne.java
+++ b/Personne.java
@@ -1,11 +1,12 @@
 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;

-    public Personne(String nom, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }

@@ -13,14 +14,29 @@ public class Personne {
     public int getAge() {
         return age;
     }
-
-    public void setNom(String nom) {
-        this.nom = nom;
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }

     public void setAge(int age) {
         this.age = age;
     }

@@ -28,7 +44,7 @@ public class Personne {
     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }

     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }

     @Override
@@ -37,9 +53,16 @@ public class Personne {
     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        Personne personne = (Personne) o;
+        return age == personne.age
+            && Objects.equals(firstName, personne.firstName)
+            && Objects.equals(lastName, personne.lastName);
     }

     @Override
@@ -48,7 +71,7 @@ public class Personne {
     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
---
test/fixtures/diffs/claude.diff:
--- Personne.java.old
+++ Personne.java.new
@@ -1,7 +1,8 @@
 import java.util.Objects;
 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;
-    public Personne(String nom, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }
-    public String getNom() {
-        return nom;
+    public String getFirstName() {
+        return firstName;
     }
+    public String getLastName() {
+        return lastName;
+    }
     public int getAge() {
         return age;
     }
-    public void setNom(String nom) {
-        this.nom = nom;
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }
     public void setAge(int age) {
         this.age = age;
@@ -19,7 +26,7 @@
     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }
     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }
     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
@@ -35,7 +42,7 @@
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        return age == personne.age && Objects.equals(firstName, personne.firstName) && Objects.equals(lastName, personne.lastName);
     }
     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
---
test/fixtures/diffs/gemini.diff:
--- a/Personne.java
+++ b/Personne.java
@@ -2,49 +2,61 @@

 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;

-    public Personne(String nom, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }

-    public String getNom() {
-        return nom;
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
     }

     public int getAge() {
         return age;
     }

-    public void setNom(String nom) {
-        this.nom = nom;
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }

     public void setAge(int age) {
         this.age = age;
     }

     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }

     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }

     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        return age == personne.age && Objects.equals(firstName, personne.firstName) && Objects.equals(lastName, personne.lastName);
     }

     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
---
test/fixtures/diffs/utils_farewell.diff:
--- a/utils.rs
+++ b/utils.rs
@@ -5,5 +5,6 @@
 }

 pub fn farewell(name: &str) -> String {
-    format!("Goodbye, {}.", name)
+    // A more formal farewell.
+    format!("Goodbye and take care, {}.", name)
 }
---
test/fixtures/diffs/utils_greet.diff:
--- a/utils.rs
+++ b/utils.rs
@@ -1,5 +1,5 @@
 // A simple utility module.

 pub fn greet(name: &str) -> String {
-    format!("Hello, {}!", name)
+    // A more enthusiastic greeting.
+    format!("Hello, {}! It is great to see you!", name)
 }

 pub fn farewell(name: &str) -> String {
---
test/fixtures/original/Personne.java:
import java.util.Objects;

public class Personne {
    private String nom;
    private int age;

    public Personne(String nom, int age) {
        this.nom = nom;
        this.age = age;
    }

    public String getNom() {
        return nom;
    }

    public int getAge() {
        return age;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void feterAnniversaire() {
        this.age++;
        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
    }

    public void saluer() {
        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
    }

    @Override
    public String toString() {
        return nom + " (Age: " + age + ")";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Personne personne = (Personne) o;
        return age == personne.age && Objects.equals(nom, personne.nom);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nom, age);
    }
}
---
test/fixtures/original/utils.rs:
// A simple utility module just for testing purposes.

pub fn greet(name: &str) -> String {
    format!("Hello, {}!", name)
}

pub fn farewell(name: &str) -> String {
    format!("Goodbye, {}.", name)
}
---
test/patching_test.rs:
use mend::{parser, patcher};

#[test]
fn test_strict_patch_succeeds() {
    // 1. ARRANGE: Set up a small, self-contained test case.
    let original = "line one\nline two\nline three";
    let diff = "@@ -1,3 +1,3 @@\n line one\n-line two\n+line two new\n line three";
    let expected = "line one\nline two new\nline three";

    // 2. ACT: Run the code you want to test.
    let parsed_diff = parser::parse_diff(diff);
    let result = patcher::apply_diff(original, &parsed_diff, 0, false);

    // 3. ASSERT: Check if the result is what you expected.
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), expected);
}

#[test]
fn test_fuzzy_patch_succeeds_when_strict_fails() {
    // ARRANGE: A case where Level 1 fuzziness is required.
    let original = "header\n\nline one\nline two\nline three";
    let diff = "@@ -1,3 +1,3 @@\n line one\n-line two\n+line two new\n line three";
    let expected = "header\n\nline one\nline two new\nline three";

    // ACT: Run with fuzziness 1.
    let parsed_diff = parser::parse_diff(diff);
    let result = patcher::apply_diff(original, &parsed_diff, 1, false);

    // ASSERT: Check the result.
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), expected);
}
---
test/setup_test_env.sh:
#!/bin/bash

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
FIXTURES_DIR="$SCRIPT_DIR/fixtures"
WORK_DIR="$SCRIPT_DIR/work"

echo "Setting up test environment in: $WORK_DIR"

if [ -d "$WORK_DIR" ]; then
    echo "  -> Removing old work directory."
    rm -rf "$WORK_DIR"
fi

echo "  -> Creating new work directory."
mkdir -p "$WORK_DIR"

echo "  -> Copying fixtures to work directory."
cp -r "$FIXTURES_DIR/original/." "$WORK_DIR/"
cp -r "$FIXTURES_DIR/diffs/." "$WORK_DIR/"

echo "-----------------------------------"
echo "Test environment is ready."
echo "You can now run mend against the files in '$WORK_DIR'"
echo "Example:"
echo "  cargo run -- '$WORK_DIR/Personne.java' '$WORK_DIR/chatgpt.diff'"
---
test/work/Personne.java:
import java.util.Objects;

public class Personne {
    private String nom;
    private int age;

    public Personne(String nom, int age) {
        this.nom = nom;
        this.age = age;
    }

    public String getNom() {
        return nom;
    }

    public int getAge() {
        return age;
    }

    public void setNom(String nom) {
        this.nom = nom;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void feterAnniversaire() {
        this.age++;
        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
    }

    public void saluer() {
        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
    }

    @Override
    public String toString() {
        return nom + " (Age: " + age + ")";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Personne personne = (Personne) o;
        return age == personne.age && Objects.equals(nom, personne.nom);
    }

    @Override
    public int hashCode() {
        return Objects.hash(nom, age);
    }
}
---
test/work/chatgpt.diff:
diff --git a/Personne.java b/Personne.java
index 1234567..89abcde 100644
--- a/Personne.java
+++ b/Personne.java
@@ -1,11 +1,12 @@
 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;

-    public Personne(String name, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }

@@ -13,14 +14,29 @@ public class Personne {
     public int getAge() {
         return age;
     }
-
-    public void setNom(String nom) {
-        this.nom = nom;
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }

     public void setAge(int age) {
         this.age = age;
     }

@@ -28,7 +44,7 @@ public class Personne {
     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }

     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }

     @Override
@@ -37,9 +53,16 @@ public class Personne {
     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
-        Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        Personne personne = (Personne) o;
+        return age == personne.age
+            && Objects.equals(firstName, personne.firstName)
+            && Objects.equals(lastName, personne.lastName);
     }

     @Override
@@ -48,7 +71,7 @@ public class Personne {
     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
---
test/work/claude.diff:
--- Personne.java.old
+++ Personne.java.new
@@ -1,7 +1,8 @@
 import java.util.Objects;
 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;
-    public Personne(String nom, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }
-    public String getNom() {
-        return nom;
+    public String getFirstName() {
+        return firstName;
     }
+    public String getLastName() {
+        return lastName;
+    }
     public int getAge() {
         return age;
     }
-    public void setNom(String nom) {
-        this.nom = nom;
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }
     public void setAge(int age) {
         this.age = age;
@@ -19,7 +26,7 @@
     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }
     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }
     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
@@ -35,7 +42,7 @@
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        return age == personne.age && Objects.equals(firstName, personne.firstName) && Objects.equals(lastName, personne.lastName);
     }
     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
---
test/work/gemini.diff:
--- a/Personne.java
+++ b/Personne.java
@@ -2,49 +2,61 @@

 public class Personne {
-    private String nom;
+    private String firstName;
+    private String lastName;
     private int age;

-    public Personne(String nom, int age) {
-        this.nom = nom;
+    public Personne(String firstName, String lastName, int age) {
+        this.firstName = firstName;
+        this.lastName = lastName;
         this.age = age;
     }

-    public String getNom() {
-        return nom;
+    public String getFirstName() {
+        return firstName;
+    }
+
+    public String getLastName() {
+        return lastName;
     }

     public int getAge() {
         return age;
     }

-    public void setNom(String nom) {
-        this.nom = nom;
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+
+    public void setLastName(String lastName) {
+        this.lastName = lastName;
     }

     public void setAge(int age) {
         this.age = age;
     }

     public void feterAnniversaire() {
         this.age++;
-        System.out.println(this.nom + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
+        System.out.println(this.firstName + " " + this.lastName + " a maintenant " + this.age + " ans. Joyeux anniversaire !");
     }

     public void saluer() {
-        System.out.println("Bonjour, je m'appelle " + this.nom + " et j'ai " + this.age + " ans.");
+        System.out.println("Bonjour, je m'appelle " + this.firstName + " " + this.lastName + " et j'ai " + this.age + " ans.");
     }

     @Override
     public String toString() {
-        return nom + " (Age: " + age + ")";
+        return firstName + " " + lastName + " (Age: " + age + ")";
     }

     @Override
     public boolean equals(Object o) {
         if (this == o) return true;
         if (o == null || getClass() != o.getClass()) return false;
         Personne personne = (Personne) o;
-        return age == personne.age && Objects.equals(nom, personne.nom);
+        return age == personne.age && Objects.equals(firstName, personne.firstName) && Objects.equals(lastName, personne.lastName);
     }

     @Override
     public int hashCode() {
-        return Objects.hash(nom, age);
+        return Objects.hash(firstName, lastName, age);
     }
 }
