# Mend

**Interactively apply messy diffs with confidence.**

Mend is a command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Where standard `patch` tools fail due to incorrect line numbers or slightly-off context, `mend` excels. It ignores line numbers and uses a powerful fuzzy-matching engine and an **interactive conflict resolution** system to ensure your changes land exactly where they should.

## Features

-   **Interactive Conflict Resolution:** Never get stuck on a failed patch again. If `mend` can't find a perfect spot or finds multiple possibilities, it prompts you to choose the correct location, skip the problematic hunk, or abort safely.
-   **CI/Scripting Friendly:** Use the `--ci` flag to run `mend` in non-interactive mode. It will fail with a non-zero exit code on any ambiguity or error, making it perfect for automated workflows.
-   **Clipboard & Stdin Support:** Paste a diff directly from your clipboard with `-c` or pipe it in from other tools like `git diff` or `cat`.

-   **Powerful Fuzzy Matching Engine:** A multi-stage algorithm that finds the correct patch location even with formatting changes, modified context lines, or other LLM-induced noise.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if the content in between has been slightly modified.

-   **Full `git diff` Support:** Seamlessly handles file creations, deletions, and modifications within a single patch file. It even creates parent directories for new files automatically.

-   **Robust Parser:** Intelligently ignores conversational artifacts, malformed headers, and other junk that LLMs sometimes include in diff code blocks.

-   **Safe and Predictable:** Applies changes only after the entire patch is successfully resolved. Use the `--dry-run` flag to preview all intended changes without touching your files.

## Installation

Ensure you have the Rust toolchain installed.

#### Using Cargo (Recommended)

This is the standard and recommended way to install Rust binaries. It compiles `mend` and places the binary in your Cargo home directory (`~/.cargo/bin`), which should be in your system's `PATH`.

```bash
git clone https://github.com/trethore/Mend.git
cd mend
cargo install --path .
```
Now you can run `mend` from anywhere in your terminal.

#### Using the install script (for system-wide installation)

If you prefer to install the binary to `/usr/local/bin` to make it available to all users on your system, you can use the provided helper script.

```bash
git clone https://github.com/trethore/Mend.git
cd mend
./install.sh
```

## Usage

### Applying a Patch from a File

`mend` auto-detects the target file from the diff header. If a single file path is given, it's assumed to be the diff file.

```bash
# Auto-detects the file from the diff and modifies it in-place
mend my_changes.diff
```

You can also specify the original file explicitly, which is useful if the diff has no headers or the patch contains changes for multiple files.
```bash
mend path/to/original_file path/to/diff_file
```

### Piping from Stdin

`mend` can read the diff from standard input, making it perfect for piping.

```bash
# Pipe a diff directly to mend (auto-detects target file from headers)
cat my_changes.diff | mend

# Pipe from git diff and specify the target file (if headers are missing/ambiguous)
git diff | mend path/to/original_file
```

### Applying from Clipboard

Copy a diff to your clipboard and apply it with the `-c` or `--clipboard` flag.

```bash
# Apply a diff from the clipboard, auto-detecting the target file
mend -c

# Apply a diff from the clipboard to a specific file
mend -c path/to/original_file
```

### Previewing Changes (Dry Run)

To see which files will be modified, created, or deleted without writing any changes, use the `--dry-run` flag.

```bash
mend --dry-run my_changes.diff
```

### Confirming Every Change

To review and confirm every hunk before it is applied, even if it's a perfect match, use the `--confirm` flag.

```bash
mend --confirm my_changes.diff
```
<!-- ADDITION START -->
### Use in Scripts and CI

For automated environments, prevent `mend` from prompting for input by using the `--ci` flag. If any hunk cannot be applied cleanly (due to an error or ambiguity), `mend` will exit with an error instead of asking for help.

```bash
# This will succeed or fail silently without user interaction
cat my_changes.diff | mend --ci
```
<!-- ADDITION END -->
### Show an Example

To see a sample diff file that `mend` understands, use the `--example` flag.

```bash
mend --example
```

## Interactive Mode in Action

If a patch hunk is ambiguous or cannot be applied, `mend` will prompt you for input.

**Ambiguous Match:**
```
[ERROR] Ambiguous match for hunk 1 in file src/main.rs. Possible locations:

> Option 1 (Line 42, Score: 0.95)
    40 | }
    41 |
    | 42  | fn main() { |
    | --- | ----------- |(Patch would be applied here, replacing 5 lines) ---
    47 |     println!("Exiting...");
    48 | }

> Option 2 (Line 118, Score: 0.85)
   116 | }
   117 |
   | 118 | fn old_main() { |
   | --- | --------------- |(Patch would be applied here, replacing 5 lines) ---
   123 |     println!("Old exit...");
   124 | }

Enter the index of the correct location, [s]kip this hunk, or [a]bort:
```

**Failed Match:**
```
[ERROR] Failed to apply hunk 2 for file src/main.rs. No matching context found.
Do you want to [s]kip this hunk or [a]bort the process? (s/a)
```

## Command-Line Reference

#### **Usage:** `mend [OPTIONS] [TARGET_FILE] [DIFF_FILE]`

#### **Arguments:**

-   `[TARGET_FILE]`: (Optional) The path to the file to be patched. If provided, `mend` will only apply hunks from the diff that match this file. If omitted, it will process all files from the diff headers.
-   `[DIFF_FILE]`: (Optional) The path to the diff/patch file. If omitted, `mend` reads from standard input.

#### **Options:**

-   `-c, --clipboard`: Read the diff content from the system clipboard.
<!-- ADDITION START -->
-   `--ci`: Run in non-interactive "CI" mode. Fails with an error instead of prompting for user input on any ambiguity or failed match.
<!-- ADDITION END -->
-   `--confirm`: Require interactive confirmation for every hunk, even perfect matches.
-   `--dry-run`: Preview all changes without writing to disk.
-   `--debug`: Enable highly detailed logs for debugging `mend` itself. Implies `--dry-run`.
-   `--example`: Print an example diff to the console and exit.
-   `-v, --verbose`: Enable verbose logging to see which files and hunks are being processed.
-   `-f, --fuzziness <LEVEL>`: Manually set the matching strategy. Default: `2`.
    -   `0`: Strict mode only (exact match).
    -   `1`: Allows whitespace and empty line differences.
    -   `2`: Enables all strategies, including the anchor-point heuristic.
-   `-m, --match-threshold <SCORE>`: Sets the minimum score (from `0.0` to `1.0`) required for a match when using the Level 2 heuristic. Default: `0.7`.

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file.

This search happens in stages to maximize accuracy and speed:
1.  **Strict Search:** First, it looks for a perfect, character-for-character match.
2.  **Whitespace-Insensitive Search:** If that fails, it normalizes whitespace and ignores blank lines to find a match.
3.  **Anchor-Point Heuristic:** As a final attempt, it uses the first and last lines of the hunk as "anchors" and searches for a region in the file that contains both, scoring the content in between for similarity. This makes it resilient to incorrect line numbers and modified context that LLMs often produce.

## Development

Contributions are welcome!

To run the test suite, simply use `cargo`. The tests are self-contained and will create their own working directories and fixtures.

```bash
cargo test
```