# Mend

Mend is a robust command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Standard `patch` tools often fail when applying AI-generated diffs because the line numbers in the `@@ ... @@` headers are incorrect. `mend` solves this by ignoring line numbers and using a powerful, multi-stage fuzzy matching algorithm to find where the patch should be applied.

## Features

-   **Robust Parsing:** Ignores malformed diff headers, comments, and other conversational artifacts from LLMs.
-   **Fuzzy Matching Engine:** If a strict patch fails, `mend` automatically uses progressively "fuzzier" strategies to find the correct location.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines, gracefully handling most formatting inconsistencies.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if context lines in between have been slightly modified.
-   **Safe by Default:** Runs in "dry run" mode by default, printing the result to the console without modifying any files.

## Installation

Ensure you have the Rust toolchain installed. You can then install `mend` directly from the source code:

```bash
git clone https://your-git-repo-url/mend.git
cd mend
cargo install --path .
```
This will compile `mend` and make it available in your shell.

## Usage

### Basic Usage (Explicit)

Apply a diff file to an original file and print the result to the console (dry run):

```bash
mend <path/to/original_file> <path/to/diff_file>
```
---

### Auto-Detecting the File to Patch

If you omit the original file, `mend` will automatically detect it from the diff header (`--- a/path/to/file`):

```bash
mend <path/to/diff_file>
```

**Example:**
```bash
mend my_changes.diff
```

### Applying In-Place

To modify the original file directly, use the `--in-place` or `-i` flag:

```bash
mend --in-place my_changes.diff
```
_**Warning:** This will overwrite your original file. Use with care!_

### Piping from Stdin

`mend` can also read the diff from standard input. This is useful for piping directly from another command (like an LLM client).

```bash
# Auto-detects the original file from the piped diff
cat my_changes.diff | mend

# You can also specify the original file explicitly
cat my_changes.diff | mend path/to/original_file
```

### Controlling Fuzziness

You can manually control the matching strategy with the `--fuzziness` or `-f` flag.

-   `--fuzziness 0`: Strict mode only. Fails if there isn't an exact match.
-   `--fuzziness 1`: Allows whitespace and empty line differences.
-   `--fuzziness 2` (Default): Enables all strategies, including the powerful anchor-point heuristic.

```bash
# Run in the strictest possible mode
mend --fuzziness 0 my_changes.diff
```

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file, making it resilient to the incorrect line numbers that LLMs often produce.