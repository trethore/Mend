# Mend

Mend is a robust command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Standard `patch` tools often fail when applying AI-generated diffs because the line numbers in the `@@ ... @@` headers are incorrect. `mend` solves this by ignoring line numbers and using a powerful, multi-stage fuzzy matching algorithm to find where the patch should be applied.

## Features

-   **Robust Parsing:** Ignores malformed diff headers, comments, and other conversational artifacts from LLMs.
-   **Fuzzy Matching Engine:** If a strict patch fails, `mend` automatically uses progressively "fuzzier" strategies to find the correct location.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines, gracefully handling most formatting inconsistencies.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if context lines in between have been slightly modified.
-   **Safe by Default:** Applies patches in-place by default, but only overwrites the original file if the entire patch can be applied successfully. If any part fails, the original file is left untouched.

## Installation

Ensure you have the Rust toolchain installed. You can then install `mend` directly from the source code:

```bash
git clone https://your-git-repo-url/mend.git
cd mend
cargo install --path .
```
This will compile `mend` and make it available in your shell.

## Usage

### Basic Usage: Applying a Patch

By default, `mend` applies the patch directly to the file detected in the diff.

```bash
# Auto-detects the original file from the diff and modifies it in-place
mend my_changes.diff
```
*If patching fails, your original file will not be modified.*

You can also specify the original file explicitly:
```bash
mend path/to/original_file path/to/diff_file
```

### Dry Run / Debugging

To see the result without modifying any files, use the `--debug` flag. This will print verbose logs and the final patched output to the console.

```bash
mend --debug my_changes.diff
```

### Piping from Stdin

`mend` can also read the diff from standard input. This is useful for piping directly from another command (like an LLM client).

```bash
# Auto-detects the original file and applies the patch in-place
cat my_changes.diff | mend

# Use --debug for a dry run from stdin
cat my_changes.diff | mend --debug
```

### Controlling Fuzziness and Verbosity

You can manually control the matching strategy with the `--fuzziness` or `-f` flag. The default is `2`.

-   `--fuzziness 0`: Strict mode only. Fails if there isn't an exact match.
-   `--fuzziness 1`: Allows whitespace and empty line differences.
-   `--fuzziness 2` (Default): Enables all strategies, including the powerful anchor-point heuristic.

```bash
# Run in the strictest possible mode
mend --fuzziness 0 my_changes.diff
```

For more detailed logs about what `mend` is doing (without a full debug dry-run), use the `--verbose` or `-v` flag.

```bash
mend --verbose my_changes.diff
```

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file, making it resilient to the incorrect line numbers that LLMs often produce.