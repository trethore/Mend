# Mend

**Interactively apply messy diffs with confidence.**

Mend is a command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Where standard `patch` tools fail due to incorrect line numbers or slightly-off context, `mend` excels. It ignores line numbers and uses a powerful fuzzy-matching engine and an **interactive conflict resolution** system to ensure your changes land exactly where they should.

## Features

-   **Interactive Conflict Resolution:** Never get stuck on a failed patch again. If `mend` can't find a perfect spot or finds multiple possibilities, it prompts you to choose the correct location, skip the problematic hunk, or abort safely.

-   **Clipboard & Stdin Support:** Paste a diff directly from your clipboard with `-c` or pipe it in from other tools like `git diff` or `cat`.

-   **Powerful Fuzzy Matching Engine:** A multi-stage algorithm that finds the correct patch location even with formatting changes, modified context lines, or other LLM-induced noise.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if the content in between has been slightly modified.

-   **Full `git diff` Support:** Seamlessly handles file creations, deletions, and modifications within a single patch file. It even creates parent directories for new files automatically.

-   **Robust Parser:** Intelligently ignores conversational artifacts, malformed headers, and other junk that LLMs sometimes include in diff code blocks.

-   **Safe and Predictable:** Applies changes only after the entire patch is successfully resolved. Use the `--dry-run` flag to preview all intended changes without touching your files.

## Installation

Ensure you have the Rust toolchain installed.

#### Using the install script (Recommended):

The script will build the project and move the binary to `/usr/local/bin`, making it available system-wide.

```bash
git clone https://github.com/trethore/Mend.git
cd mend
./install.sh
```

#### Using Cargo:

You can also install the binary directly into your cargo home directory.

```bash
git clone https://your-git-repo-url/mend.git
cd mend
cargo install --path .
```

This will compile `mend` and make it available in your shell.

## Usage

### Applying a Patch from a File

`mend` auto-detects the target file from the diff header. If a single file path is given, it's assumed to be the diff file.

```bash
# Auto-detects the file from the diff and modifies it in-place
mend my_changes.diff
```

You can also specify the original file explicitly, which is useful if the diff has no headers.
```bash
mend path/to/original_file path/to/diff_file
```

### Piping from Stdin

`mend` can read the diff from standard input, making it perfect for piping.

```bash
# Pipe a diff directly to mend (auto-detects target file from headers)
cat my_changes.diff | mend

# Pipe from git diff and specify the target file (if headers are missing/ambiguous)
git diff | mend path/to/original_file
```

### Applying from Clipboard

Copy a diff to your clipboard and apply it with the `-c` or `--clipboard` flag.

```bash
# Apply a diff from the clipboard, auto-detecting the target file
mend -c

# Apply a diff from the clipboard to a specific file
mend -c path/to/original_file
```

### Previewing Changes (Dry Run)

To see which files will be modified, created, or deleted without writing any changes, use the `--dry-run` flag.

```bash
mend --dry-run my_changes.diff
```

### Show an Example

To see a sample diff file that `mend` understands, use the `--example` flag.

```bash
mend --example
```

## Interactive Mode in Action

If a patch hunk is ambiguous or cannot be applied, `mend` will prompt you for input.

**Ambiguous Match:**
```
[ERROR] Ambiguous match for hunk 1 in file src/main.rs. Possible locations:

> Option 1 (Line 42, Score: 0.95)
    40 | }
    41 |
    | 42  | fn main() { |
    | --- | ----------- |(Patch would be applied here, replacing 5 lines) ---
    47 |     println!("Exiting...");
    48 | }

> Option 2 (Line 118, Score: 0.85)
   116 | }
   117 |
   | 118 | fn old_main() { |
   | --- | --------------- |(Patch would be applied here, replacing 5 lines) ---
   123 |     println!("Old exit...");
   124 | }

Enter the index of the correct location, [s]kip this hunk, or [a]bort:
```

**Failed Match:**
```
[ERROR] Failed to apply hunk 2 for file src/main.rs. No matching context found.
Do you want to [s]kip this hunk or [a]bort the process? (s/a)
```

## Command-Line Reference

#### **Usage:** `mend [OPTIONS] [TARGET_FILE] [DIFF_FILE]`

#### **Arguments:**

-   `[TARGET_FILE]`: (Optional) The path to the file to be patched. If omitted, `mend` will try to determine the file from the diff headers.
-   `[DIFF_FILE]`: (Optional) The path to the diff/patch file. If omitted, `mend` reads from standard input.

#### **Options:**

-   `-c, --clipboard`: Read the diff content from the system clipboard.
-   `--dry-run`: Preview all changes without writing to disk.
-   `--debug`: Enable highly detailed logs for debugging `mend` itself. Implies `--dry-run`.
-   `--example`: Print an example diff to the console and exit.
-   `-v, --verbose`: Enable verbose logging to see which files and hunks are being processed.
-   `-f, --fuzziness <LEVEL>`: Manually set the matching strategy. Default: `2`.
    -   `0`: Strict mode only (exact match).
    -   `1`: Allows whitespace and empty line differences.
    -   `2`: Enables all strategies, including the anchor-point heuristic.
-   `-m, --match-threshold <SCORE>`: Sets the minimum score (from `0.0` to `1.0`) required for a match when using the Level 2 heuristic. Default: `0.7`.

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file, making it resilient to the incorrect line numbers that LLMs often produce.