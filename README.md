# Mend

**Interactively apply messy diffs with confidence.**

Mend is a command-line tool designed to reliably apply diffs, especially those generated by Large Language Models (LLMs).

Where standard `patch` tools fail due to incorrect line numbers or slightly-off context, `mend` excels. It ignores line numbers and uses a powerful fuzzy-matching engine and an **interactive conflict resolution** system to ensure your changes land exactly where they should.

## Features

-   **Interactive Conflict Resolution:** Never get stuck on a failed patch again. If `mend` can't find a perfect spot or finds multiple possibilities, it prompts you to choose the correct location, skip the problematic hunk, or abort safely.
-   **CI/Scripting Friendly:** Use the `--ci` flag to run `mend` in non-interactive mode. It will fail with a non-zero exit code on any ambiguity or error, making it perfect for automated workflows.
-   **Clipboard & Stdin Support:** Paste a diff directly from your clipboard with `-c` or pipe it in from other tools like `git diff` or `cat`.

-   **Powerful Fuzzy Matching Engine:** A multi-stage algorithm that finds the correct patch location even with formatting changes, modified context lines, or other LLM-induced noise.
    -   **Level 0 (Strict):** An exact, line-by-line match.
    -   **Level 1 (Whitespace Insensitive):** Ignores leading/trailing whitespace and empty lines.
    -   **Level 2 (Anchor-Point Heuristic):** Uses the first and last lines of a change block as anchors to find the location, even if the content in between has been slightly modified.

-   **Full `git diff` Support:** Seamlessly handles file creations, deletions, and modifications within a single patch file. It even creates parent directories for new files automatically.

-   **Robust Parser:** Intelligently ignores conversational artifacts, malformed headers, and other junk that LLMs sometimes include in diff code blocks.

-   **Safe and Predictable:** Applies changes only after the entire patch is successfully resolved. Use the `--dry-run` flag to preview all intended changes without touching your files.

## Installation

Ensure you have the Rust toolchain installed.

#### Using Cargo (Recommended)

This is the standard and recommended way to install Rust binaries. It compiles `mend` and places the binary in your Cargo home directory (`~/.cargo/bin`), which should be in your system's `PATH`.

```bash
git clone https://github.com/trethore/Mend.git
cd mend
cargo install --path .
```
Now you can run `mend` from anywhere in your terminal.

#### Using the install script (for system-wide installation)

If you prefer to install the binary to `/usr/local/bin` to make it available to all users on your system, you can use the provided helper script.

```bash
git clone https://github.com/trethore/Mend.git
cd mend
./install.sh
```

## Usage

### Applying a Patch from a File

`mend` auto-detects the target file from the diff header. If a single file path is given, it's assumed to be the diff file.

```bash
# Auto-detects the file from the diff and modifies it in-place
mend my_changes.diff
```

You can also specify the original file explicitly, which is useful if the diff has no headers or the patch contains changes for multiple files.
```bash
# Apply diff contents in 'my_changes.diff' to the file 'path/to/original_file'
mend path/to/original_file my_changes.diff
```

### Positional Arg Rules & Examples

- Single positional argument: interpreted as the diff file (`mend my_changes.diff`).
- Two positional arguments: first is target file, second is diff file (`mend <TARGET_FILE> <DIFF_FILE>`).
- If you provide exactly one positional argument but also use `-c/--clipboard`, that argument is treated as the target file.

Examples:

```bash
# Apply a diff file (auto-detect target from diff headers)
mend my_changes.diff

# Apply a diff file to a specific target file (ignore headers)
mend src/main.rs my_changes.diff

# Pipe a diff from git and auto-detect target files
git diff | mend

# Pipe a diff from git into a specific target file
git diff | mend src/main.rs

# Use clipboard as diff source and target (explicit)
mend -c src/lib.rs
```

### Piping from Stdin

`mend` can read the diff from standard input, making it perfect for piping.

```bash
# Pipe a diff directly to mend (auto-detects target file from headers)
cat my_changes.diff | mend

# Pipe from git diff and specify the target file (if headers are missing/ambiguous)
git diff | mend path/to/original_file
```

### Applying from Clipboard

Copy a diff to your clipboard and apply it with the `-c` or `--clipboard` flag.

```bash
# Apply a diff from the clipboard, auto-detecting the target file
mend -c

# Apply a diff from the clipboard to a specific file
mend -c path/to/original_file
```

### Previewing Changes (Dry Run)

To see which files will be modified, created, or deleted without writing any changes, use the `--dry-run` flag.

```bash
mend --dry-run my_changes.diff
```

### Confirming Every Change

To review and confirm every hunk before it is applied, even if it's a perfect match, use the `--confirm` flag.

```bash
mend --confirm my_changes.diff
```

### Reverting a Patch

To undo a patch that has already been applied, use the `-r` or `--revert` flag. `mend` will invert the diff and use its fuzzy-matching engine to find where the change was applied and revert it.

```bash
# Revert the changes contained in the diff file
mend -r my_changes.diff
```

<!-- ADDITION START -->
### Use in Scripts and CI

`--ci` (CI mode): run `mend` non-interactively. In this mode, any ambiguous or failed hunk will cause `mend` to exit with a non-zero status rather than prompting for input. Use `--ci` when running in automated pipelines.

`--silent`: suppresses success output and makes the run quieter. When combined with `--ci`, `--silent` will cause `mend` to only emit errors on failure (no summary on success). Note: `--silent` conflicts with `--verbose`, `--debug`, and `--confirm` and will make ambiguous/failed hunks error rather than prompting.

`--debug`: enables detailed debug logging. `--debug` is primarily for troubleshooting; it implies `--dry-run` in output handling (debug runs do not write changes unless you remove `--dry-run`), but it remains interactive (it will still prompt for confirmations) unless you explicitly add `--ci` or `--silent`.

Examples:

```bash
# Non-interactive CI-friendly run (errors on ambiguity)
cat my_changes.diff | mend --ci

# Non-interactive and quiet (exit code indicates success/failure)
cat my_changes.diff | mend --ci --silent

# Run with detailed debug logs (useful for troubleshooting). Note: debug prints a lot of information and keeps interactive prompts unless used with --ci.
mend --debug my_changes.diff
```

<!-- ADDITION END -->

### Show an Example

To see a sample diff file that `mend` understands, use the `--example` flag.

```bash
mend --example
```

## Interactive Mode in Action

If a patch hunk is ambiguous or cannot be applied, `mend` will prompt you for input.

**Ambiguous Match:**
```
[ERROR] Ambiguous match for hunk 1 in file src/main.rs. Possible locations:

> Option 1 (Line 42, Score: 0.95)
    40 | }
    41 |
    | 42  | fn main() { |
    | --- | ----------- |(Patch would be applied here, replacing 5 lines) ---
    47 |     println!("Exiting...");
    48 | }

> Option 2 (Line 118, Score: 0.85)
   116 | }
   117 |
   | 118 | fn old_main() { |
   | --- | --------------- |(Patch would be applied here, replacing 5 lines) ---
   123 |     println!("Old exit...");
   124 | }

Enter the index of the correct location, [s]kip this hunk, or [a]bort:
```

**Failed Match:**
```
[ERROR] Failed to apply hunk 2 for file src/main.rs. No matching context found.
Do you want to [s]kip this hunk or [a]bort the process? (s/a)
```

## Command-Line Reference

#### **Usage:** `mend [OPTIONS] [TARGET_FILE] [DIFF_FILE]`

#### **Arguments:**

-   `[TARGET_FILE]`: (Optional) The path to the file to be patched. If provided, `mend` will only apply hunks from the diff that match this file. If omitted, it will process all files from the diff headers.
-   `[DIFF_FILE]`: (Optional) The path to the diff/patch file. If omitted, `mend` reads from standard input.

#### **Options (quick reference):**

-   `-c, --clipboard`: Read the diff content from the system clipboard.
-   `--ci`: Run in non-interactive "CI" mode. Any ambiguous or failed hunk causes an error (non-zero exit) instead of prompting.
-   `--confirm`: Require interactive confirmation for every hunk, even perfect matches.
-   `-r, --revert`: Invert the given diff and apply it (useful to undo a previous patch).
-   `--dry-run`: Preview all changes without writing to disk.
-   `--debug`: Enable detailed debug logs. Debug enables verbose internal logs and is intended for troubleshooting; it keeps the run interactive unless `--ci` or `--silent` is also used.
-   `--example`: Print an example diff to the console and exit.
-   `-s, --silent`: Suppress success output (prints nothing on success). In interactive contexts, `--silent` will also cause ambiguous/failed hunks to error rather than prompt. Conflicts with `--verbose`, `--debug`, and `--confirm`.
-   `-v, --verbose`: Enable verbose logging to see which files and hunks are being processed.
-   `-f, --fuzziness <LEVEL>`: Manually set the matching strategy. Default: `2`.
    -   `0`: Strict mode only (exact match).
    -   `1`: Allows whitespace and empty line differences.
    -   `2`: Enables all strategies, including the anchor-point heuristic.
-   `-m, --match-threshold <SCORE>`: Sets the minimum score (from `0.0` to `1.0`) required for a match when using the Level 2 heuristic. Default: `0.7`.

For automation, prefer `--ci` (make runs non-interactive). Add `--silent` for quiet CI runs where only exit codes and stderr matter.

## How It Works

`mend` operates on a simple but powerful principle: **trust the content, not the coordinates.** It parses the context lines (` `) and removal lines (`-`) from a diff hunk and searches for that block of text in the original file.

This search happens in stages to maximize accuracy and speed:
1.  **Strict Search:** First, it looks for a perfect, character-for-character match.
2.  **Whitespace-Insensitive Search:** If that fails, it normalizes whitespace and ignores blank lines to find a match.
3.  **Anchor-Point Heuristic:** As a final attempt, it uses the first and last lines of the hunk as "anchors" and searches for a region in the file that contains both, scoring the content in between for similarity. This makes it resilient to incorrect line numbers and modified context that LLMs often produce.

## Development

Contributions are welcome!

To run the test suite, simply use `cargo`. The tests are self-contained and will create their own working directories and fixtures.

```bash
cargo test
```